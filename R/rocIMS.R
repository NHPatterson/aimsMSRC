#'@export
#'@import pROC
#'@title Calculate ROC curve for IMS signals accross regions of interest
#'@description Calculates the ROC curve and generates a list of pROC objects based on user defined mz vector
#'@param cardinaldata MSImageSet containing pixels and intensity data for ROC calculation
#'@param mzs vector of mz values to run ROC calculation, or 'all' to run on all mzs in dataset
#'@param positiveROI boolean vector in MSImageSet pixelData generated by selectROI function, defines 'cases' in ROC calculation
#'@param negativeROI boolean vector in MSImageSet pixelData generated by selectROI function, defines 'control' in ROC calculation, alternatively use 'all' to do the positiveROI vs. all other pixels in the dataset
#'@param subset boolean, if one class has more samples than another, randomly subset the longer to match the number of samples in the shorter
#'@return list of pROC analyses sorted descending by area under the ROC curve

rocIMS <- function(cardinaldata, mzs = 687.5, positiveROI = 'myROI1', negativeROI = 'myROI2', undersampling=T){

  tryCatch({
    positiveBoolean <- pData(cardinaldata)[positiveROI][,1]
  },
  error= function(e){
    stop(paste0('\'',positiveROI,'\'', ' ROI not found in pixelData of ',  deparse(substitute(cardinaldata))), call.=F)
  })

  if(negativeROI != 'all'){
    tryCatch({
      negativeBoolean <- pData(cardinaldata)[negativeROI][,1]
    },
    error= function(e){
      stop(paste0('\'',negativeROI,'\'', ' ROI not found in pixelData of ',  deparse(substitute(cardinaldata))), call.=F)
    })

    overlapping_pixels <- as.numeric(positiveBoolean) +  as.numeric(negativeBoolean)

    ##we will modify this to include other sampling options in overlap scenarios, right now we just remove

    if (length(which(overlapping_pixels == 2)) > 0){
      print('overlapping ROIs, removing overlaps')
      positiveBoolean[which(overlapping_pixels == 2)] = FALSE
      negativeBoolean[which(overlapping_pixels == 2)] = FALSE

    }

  }else{
    ## in all scenario, we just invert the positive boolean
    negativeBoolean <- !positiveBoolean
  }

  pos_idx = which(positiveBoolean == T)
  neg_idx = which(negativeBoolean == T)

  if(undersampling == T){
    if(length(pos_idx)  > length(neg_idx)){

      pos_idx = sample(pos_idx, length(neg_idx))

    }else{

      neg_idx = sample(neg_idx, length(pos_idx))

    }
  }

  roc_response = c(rep(0, length(neg_idx)), rep(1, length(pos_idx)))

  roc_curves = list()


  if(mzs == 'all'){
    mzs = Cardinal::mz(cardinaldata)
  }

  for(mz in mzs){
    mz_idx <- features(cardinaldata, mz=mz)
    roc_curves[[as.character(round(mz,3))]] = roc(controls =  as.numeric(iData(cardinaldata)[mz_idx,neg_idx]),
                                                  cases =  as.numeric(iData(cardinaldata)[mz_idx,pos_idx]),
                                                  direction = '<',
                                                  algorithm = 3)

  }

  auROCs <- sapply(roc_curves, function(x) x$auc[1])
  order_idx = order(auROCs, decreasing = T)

  roc_curves = roc_curves[order_idx]

  return(roc_curves)
}



